structure A = Absyn


%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | UMINUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE 

%nonterm  program of A.exp |
  val_exp of A.exp | no_val_exp of A.exp |
  exp of A.exp | exps of (A.exp * A.pos) list | 
  decs of A.dec list | dec of A.dec | 
  oper of A.oper | 
  lval of A.var | lval' of A.var | 
  vardec of A.dec |
  ty of A.ty | tyfield of A.field | tyfields of A.field list | 
  tydec of {name: A.symbol, ty: A.ty, pos: A.pos} | tydecs of {name: A.symbol, ty: A.ty, pos: A.pos} list | tydec_wrap of A.dec |
  fundec of A.fundec | fundecs of A.fundec list | fundec_wrap of A.dec |
  callParams of A.exp list

%nonassoc EQ NEQ LT LE GT GE
%right SEMICOLON
%left OR
%left AND
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS



%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

program:        exp                                       (exp)

exp:            no_val_exp                                (no_val_exp)
exp:            val_exp                                   (val_exp)
	
val_exp:        NIL		                                    (A.NilExp)
val_exp:        INT                                       (A.IntExp(INT))
val_exp:	      STRING					                          (A.StringExp(STRING, STRINGleft))

callParams:     exp                                       (exp::nil)
callParams:     exp callParams                            (exp :: callParams)
no_val_exp:     ID LPAREN callParams RPAREN               (A.CallExp{func=(Symbol.symbol ID), args=callParams, pos=IDleft})


val_exp:        ID                                        (A.VarExp (A.SimpleVar(Symbol.symbol ID, IDleft)))
val_exp:        lval'                                     (A.VarExp lval')

lval:           ID                                        (A.SimpleVar(Symbol.symbol ID, IDleft))
lval:           lval'                                     (lval')
lval':          lval DOT ID                               (A.FieldVar(lval, Symbol.symbol ID, lvalleft))
lval':          ID LBRACK exp RBRACK                      (A.SubscriptVar((A.SimpleVar(Symbol.symbol ID, IDleft)), exp, IDleft))
lval':          lval' LBRACK exp RBRACK                   (A.SubscriptVar(lval', exp, lval'left))


val_exp:        LPAREN exps RPAREN                        (A.SeqExp exps)
exps:           exp                                       ((exp, expleft) :: nil)
exps:           exp SEMICOLON exps                        ((exp, expleft) :: exps)

no_val_exp:     ID LBRACK val_exp RBRACK OF exp           (A.ArrayExp {typ=(Symbol.symbol ID), size=val_exp, init=exp, pos=IDleft})

no_val_exp:     LET decs IN exp END                       (A.LetExp {decs=decs, body=exp, pos=LETleft})   
decs:		        dec						                            (dec::nil)
decs:		        dec decs					                        (dec::decs)

dec:            vardec                                    (vardec)
dec:            fundec_wrap                               (fundec_wrap)
dec:            tydec_wrap                                (tydec_wrap)

vardec:         VAR ID ASSIGN exp                         (A.VarDec {name=(Symbol.symbol ID), escape=(ref false), typ=NONE, init=exp, pos=VARleft})
vardec:         VAR ID COLON ID ASSIGN exp                (A.VarDec {name=(Symbol.symbol ID1), escape=(ref false), typ=SOME(Symbol.symbol ID2, ID2left), init=exp, pos=VARleft})

fundec_wrap:		fundecs					                          (A.FunctionDec fundecs)
fundecs:	      fundec					                          (fundec::nil)
fundecs: 	      fundec fundecs				                    (fundec::fundecs)

fundec:         FUNCTION ID LPAREN tyfields RPAREN EQ exp 		      ({name=(Symbol.symbol ID), params=tyfields, result=NONE, body=exp, pos=FUNCTIONleft})
fundec:         FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp 	({name=(Symbol.symbol ID1), params=tyfields, result=SOME(Symbol.symbol ID2, ID2left), body=exp, pos=FUNCTIONleft})


tydec_wrap:     tydecs                                    (A.TypeDec tydecs)
tydecs:		      tydec		 			                            (tydec::nil)
tydecs:		      tydec tydecs				                      (tydec :: tydecs)

tydec:		      TYPE ID EQ ty				                      ({name=(Symbol.symbol ID), ty=ty, pos=TYPEleft})

ty:		          ID					                              (A.NameTy (Symbol.symbol ID, IDleft))
ty: 		        ARRAY OF ID				                        (A.ArrayTy (Symbol.symbol ID, IDleft))
ty:		          LBRACE tyfields RBRACE			              (A.RecordTy (tyfields))

tyfield: 	      ID COLON ID				                        ({name=(Symbol.symbol ID1), escape=(ref false), typ=(Symbol.symbol ID2), pos=ID1left})
tyfields: 	    tyfield					                          (tyfield :: nil)
tyfields:	      tyfield COMMA tyfields	 		              (tyfield :: tyfields)
tyfields:       NIL                                       ([])

val_exp:        MINUS val_exp                %prec UMINUS (A.OpExp {left=A.IntExp(0), oper=A.MinusOp, right=val_exp, pos=MINUSleft})
val_exp:        val_exp TIMES val_exp                     (A.OpExp {left=val_exp1, oper=A.TimesOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp DIVIDE val_exp                    (A.OpExp {left=val_exp1, oper=A.DivideOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp PLUS val_exp                      (A.OpExp {left=val_exp1, oper=A.PlusOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp MINUS val_exp                     (A.OpExp {left=val_exp1, oper=A.MinusOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp EQ val_exp                        (A.OpExp {left=val_exp1, oper=A.EqOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp NEQ val_exp                       (A.OpExp {left=val_exp1, oper=A.NeqOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp LT val_exp                        (A.OpExp {left=val_exp1, oper=A.LtOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp LE val_exp                        (A.OpExp {left=val_exp1, oper=A.LeOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp GT val_exp                        (A.OpExp {left=val_exp1, oper=A.GtOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp GE val_exp                        (A.OpExp {left=val_exp1, oper=A.GeOp, right=val_exp2, pos=val_exp1left})
