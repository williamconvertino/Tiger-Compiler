structure A = Absyn

%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | UMINUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE 

%nonterm  program of A.exp |
  exp of A.exp | exps of (A.exp * A.pos) list | 
  decs of A.dec list | dec of A.dec | 
  oper of A.oper | 
  lval of A.var | lval' of A.var

%nonassoc EQ NEQ LT LE GT GE
%right SEMICOLON
%left OR
%left AND
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS
%right LBRACK



%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

program:  exp                               (exp)

	
exp:      NIL		                            (A.NilExp)
exp:      INT                               (A.IntExp(INT))

exp:      ID                                (A.VarExp (A.SimpleVar(Symbol.symbol ID, IDleft)))
exp:      lval'                             (A.VarExp lval')

lval:     ID                                (A.SimpleVar(Symbol.symbol ID, IDleft))
lval:     lval'                             (lval')
lval':    lval DOT ID                       (A.FieldVar(lval, Symbol.symbol ID, lvalleft))
lval':    ID LBRACK exp RBRACK              (A.SubscriptVar((A.SimpleVar(Symbol.symbol ID, IDleft)), exp, IDleft))
lval':    lval' LBRACK exp RBRACK           (A.SubscriptVar(lval', exp, lval'left))



exp:      LPAREN exps RPAREN                (A.SeqExp exps)
exps:     exp                               ((exp, expleft) :: nil)
exps:     exp SEMICOLON exps                ((exp, expleft) :: exps)

exp:      ID LBRACK exp RBRACK OF exp        (A.ArrayExp {typ=(Symbol.symbol ID), size=exp1, init=exp2, pos=IDleft})

exp:      LET decs IN exp END               (A.LetExp {decs=decs, body=exp, pos=LETleft})   
decs:     dec                               (dec :: nil)
decs:     dec decs                          (dec :: decs)

dec:      VAR ID ASSIGN exp                 (A.VarDec {name=(Symbol.symbol ID), escape=(ref false), typ=NONE, init=exp, pos=VARleft})

exp:      MINUS exp            %prec UMINUS (A.OpExp {left=A.IntExp(0), oper=A.MinusOp, right=exp, pos=MINUSleft})
exp:      exp oper exp                      (A.OpExp {left=exp1, oper=oper, right=exp2, pos=exp1left})
oper:     TIMES                             (A.TimesOp)
oper:     DIVIDE                            (A.DivideOp)
oper:     PLUS                              (A.PlusOp)
oper:     MINUS                             (A.MinusOp)
oper:     EQ                                (A.EqOp)
oper:     NEQ                               (A.NeqOp)
oper:     LT                                (A.LtOp)
oper:     LE                                (A.LeOp)
oper:     GT                                (A.GtOp)
oper:     GE                                (A.GeOp)