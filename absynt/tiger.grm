structure A = Absyn

%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | UMINUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE 

%nonterm  program of A.exp |
  val_exp of A.exp | no_val_exp of A.exp |
  exp of A.exp | exps of (A.exp * A.pos) list | 
  decs of A.dec list | dec of A.dec | 
  oper of A.oper | 
  lval of A.var | lval' of A.var 
  
%nonassoc EQ NEQ LT LE GT GE
%right SEMICOLON
%left OR
%left AND
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS



%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

program:        exp                                       (exp)

exp:            no_val_exp                                (no_val_exp)
exp:            val_exp                                   (val_exp)
	
val_exp:        NIL		                                    (A.NilExp)
val_exp:        INT                                       (A.IntExp(INT))

val_exp:        ID                                        (A.VarExp (A.SimpleVar(Symbol.symbol ID, IDleft)))
val_exp:        lval'                                     (A.VarExp lval')

lval:           ID                                        (A.SimpleVar(Symbol.symbol ID, IDleft))
lval:           lval'                                     (lval')
lval':          lval DOT ID                               (A.FieldVar(lval, Symbol.symbol ID, lvalleft))
lval':          ID LBRACK exp RBRACK                      (A.SubscriptVar((A.SimpleVar(Symbol.symbol ID, IDleft)), exp, IDleft))
lval':          lval' LBRACK exp RBRACK                   (A.SubscriptVar(lval', exp, lval'left))



val_exp:        LPAREN exps RPAREN                        (A.SeqExp exps)
exps:           exp                                       ((exp, expleft) :: nil)
exps:           exp SEMICOLON exps                        ((exp, expleft) :: exps)

no_val_exp:     ID LBRACK val_exp RBRACK OF exp           (A.ArrayExp {typ=(Symbol.symbol ID), size=val_exp, init=exp, pos=IDleft})

no_val_exp:     LET decs IN exp END                       (A.LetExp {decs=decs, body=exp, pos=LETleft})   
decs:           dec                                       (dec :: nil)
decs:           dec decs                                  (dec :: decs)

dec:            VAR ID ASSIGN exp                         (A.VarDec {name=(Symbol.symbol ID), escape=(ref false), typ=NONE, init=exp, pos=IDleft})

val_exp:        MINUS val_exp                %prec UMINUS (A.OpExp {left=A.IntExp(0), oper=A.MinusOp, right=val_exp, pos=MINUSleft})
val_exp:        val_exp TIMES val_exp                     (A.OpExp {left=val_exp1, oper=A.TimesOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp DIVIDE val_exp                    (A.OpExp {left=val_exp1, oper=A.DivideOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp PLUS val_exp                      (A.OpExp {left=val_exp1, oper=A.PlusOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp MINUS val_exp                     (A.OpExp {left=val_exp1, oper=A.MinusOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp EQ val_exp                        (A.OpExp {left=val_exp1, oper=A.EqOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp NEQ val_exp                       (A.OpExp {left=val_exp1, oper=A.NeqOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp LT val_exp                        (A.OpExp {left=val_exp1, oper=A.LtOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp LE val_exp                        (A.OpExp {left=val_exp1, oper=A.LeOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp GT val_exp                        (A.OpExp {left=val_exp1, oper=A.GtOp, right=val_exp2, pos=val_exp1left})
val_exp:        val_exp GE val_exp                        (A.OpExp {left=val_exp1, oper=A.GeOp, right=val_exp2, pos=val_exp1left})

val_exp:        IF val_exp THEN val_exp ELSE val_exp      (A.IfExp {test=val_exp1, then'=val_exp2, else'=(SOME val_exp3), pos=IFleft})
no_val_exp:     IF val_exp THEN no_val_exp                (A.IfExp {test=val_exp, then'=no_val_exp, else'=NONE, pos=IFleft})

no_val_exp:     WHILE val_exp DO no_val_exp               (A.WhileExp {test=val_exp, body=no_val_exp, pos=WHILEleft})
no_val_exp:     FOR ID ASSIGN val_exp TO val_exp DO no_val_exp   (A.ForExp {var=(Symbol.symbol ID), escape=(ref false), lo=val_exp1, hi=val_exp2, body=no_val_exp, pos=FORleft})

no_val_exp:     BREAK                                     (A.BreakExp BREAKleft)
